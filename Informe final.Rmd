---
title: "¿Como conseguir un mejor descanso?"
author: 'Autor: Isanagui Rojas Martínez'
date: "`r Sys.Date()`"
output: pdf_document
subtitle: Análisis para la optimización del sueño
---

<style>
body {
  text-align: justify;
}
</style>

```{r Script, include=FALSE}
library(jsonlite)

base_path <- "C:/Users/TITAN OSCURO/Desktop/POSTGRAU EN ANALÍTICA DE DADES I PROGRAMACIÓ APLICADES A LES CIÈNCIES SOCIALS 2022-2023/R/Trabajo final/DI-Connect-Wellness - abril"

sleep1 <- fromJSON(file.path(base_path, "2022-06-03_2022-09-11_105448003_sleepData.json"))
sleep2 <- fromJSON(file.path(base_path, "2022-09-11_2022-12-20_105448003_sleepData.json"))
sleep3 <- fromJSON(file.path(base_path, "2022-12-20_2023-03-30_105448003_sleepData.json"))

data.frame(sleep1)
data.frame(sleep2)
data.frame(sleep3)

colnames(sleep1) #tiene 2 variables mas que los otros conjuntos de datos)
colnames(sleep2)
colnames(sleep3)

#numero variables total de los conjuntos de datos

sleep1t<-sleep1
sleep2t<-sleep2
sleep3t<-sleep3

sleep1$userNote <- NULL
sleep1$sleepResultType <- NULL #estas 2 variables solo estan en sleep1

#Las siguientes variables no aportan valor al conjunto de los datos
sleep1$unmeasurableSeconds <- NULL 
sleep2$unmeasurableSeconds <- NULL
sleep3$unmeasurableSeconds <- NULL

sleep1$retro <- NULL
sleep2$retro <- NULL
sleep3$retro <- NULL

sleep1$sleepWindowConfirmationType <- NULL
sleep2$sleepWindowConfirmationType <- NULL
sleep3$sleepWindowConfirmationType <- NULL

# El problema estava en que dues de les columnes del dataframe eren llistes (spo2SleepSummary,sleepScores)

library(tidyr)

sleep1 <- unnest(sleep1, col = c(spo2SleepSummary,sleepScores))
sleep2 <- unnest(sleep2, col = c(spo2SleepSummary,sleepScores))
sleep3 <- unnest(sleep3, col = c(spo2SleepSummary,sleepScores))

sleep123t <- rbind(sleep1, sleep2, sleep3) 

sleep123 <- sleep123t

#Limpieza de variables tras la union de los 3 conjuntos de datos que no aportan valor

sleep123$deviceId <- NULL 
sleep123$userProfilePk <- NULL
sleep123$sleepStartTimestampGMT <- NULL #esta es igual que sleepMeasurementStartGMT la diferencia es de unos minutos
sleep123$sleepEndTimestampGMT <- NULL #esta es igual que sleepMeasurementEndGMT la diferencia es de unos minutos
sleep123$insight <- NULL #elimino esta variable no aporta valor muchos NONE, no aporta valor

#Transformacion de las variables calendario sleep123 para que sean dates

sleep123$calendarDate<-as.Date(sleep123$calendarDate)

sleep123$sleepMeasurementStartGMT <- as.POSIXct(sleep123$sleepMeasurementStartGMT, format = "%Y-%m-%dT%H:%M:%OS")
sleep123$sleepMeasurementEndGMT <- as.POSIXct(sleep123$sleepMeasurementEndGMT, format = "%Y-%m-%dT%H:%M:%OS")

#Las variables de 2:5 estan en segundos pasarlas a minutos

sleep123$deepSleepMin <- sleep123$deepSleepSeconds/60
sleep123$lightSleepMin <- sleep123$lightSleepSeconds/60
sleep123$remSleepMin <- sleep123$remSleepSeconds/60
sleep123$awakeSleepMin <-sleep123$awakeSleepSeconds/60

#Eliminar variables segundos de sueño

sleep123$deepSleepSeconds <- NULL
sleep123$lightSleepSeconds<- NULL
sleep123$remSleepSeconds<- NULL
sleep123$awakeSleepSeconds<- NULL

#Suma de variables del sueño (deepsleep, lightsleep, remsleep, awakesleep) para calcular sueño total y pasarlo de minutos a horas

totalsleepMin <- sleep123$deepSleepMin+sleep123$lightSleepMin+sleep123$remSleepMin+sleep123$awakeSleepMin
totalsleepH<-round(totalsleepMin/60,2)

sleep123$avgSleepStress<-round(sleep123$avgSleepStress,2)

#Unir y reordenar la nueva variable de sueño total en minutos y horas al data frame y ponerlo en orden

library(dplyr)

sleep123<-cbind(sleep123,totalsleepMin,totalsleepH)
sleep123<-dplyr::select(sleep123,calendarDate,deepSleepMin,lightSleepMin,remSleepMin,awakeSleepMin,totalsleepMin,totalsleepH,everything())

names(sleep123)
# Recorrer cada variable del data frame y transformarla en tipo numerico

for (i in seq_along(sleep123)){
  if (is.integer(sleep123[,i])){
    sleep123[, i] <- as.numeric(sleep123[, i])
  }else{
    next
  }
}

sleep123$feedback<-as.factor(sleep123$feedback) #esta variable es un factor

#Eliminar NA y casos no validos

sleep.no.na<-sleep123[!sleep123$overallScore==0,] #se eliminan 3 casos que no tienen metricas para hacer la puntuacion total del sueño

sleep.no.na <- na.omit(sleep.no.na) # se eleminan 34 casos con NA

sleep.no.na$feedback <- NULL

##grafico dispersion calidad del sueño

library(ggplot2)

#creacion grupos de sueño

grupos <- cut(sleep.no.na$overallScore, 
              breaks = c(0, 60, 79, 89, 100),
              labels = c("Pobre", "Justo", "Bueno", "Excelente"))

# Cálculo de frecuencia y porcentaje de cada grupo

grupos_count <- table(grupos)
total_casos <- sum(grupos_count)

# Modificación de la variable grupo_label para incluir el rango de cada etiqueta

grupo_range <- c("0-60", "60-79", "79-89", "89-100")
grupo_label <- paste0(names(grupos_count), " (", grupo_range, "): n = ", grupos_count, " (", 
                      round(100*grupos_count/total_casos,2), "%)")

# Creación del gráfico

ggplot(sleep.no.na, aes(x = totalsleepH, y = overallScore)) +
  geom_point(aes(color = grupos), alpha = 0.7, size = 3, position = "jitter") + 
  ylab("Puntuación del sueño") + 
  xlab("Horas sueño") +
  ggtitle("Gráfico calidad del sueño por grupos") +
  scale_x_continuous(limits = c(3,12.5), breaks = seq(3,12.5,1)) +
  scale_color_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#9C27B0"),
                     labels = grupo_label) +
  labs(color = "Calidad del sueño") +
  guides(color = guide_legend(title = paste0("Grupos (n = ", total_casos, ")"), 
                              ncol = 1, 
                              override.aes = list(size = 3, alpha = 0.4)))

#Linea temporal del sueño por dia

library(lubridate)

sleep_dia <- sleep.no.na %>%
  group_by(Dia = floor_date(calendarDate, unit = "day")) %>%
  summarize(media_de_datos = overallScore)

#Linea temporal del sueño por semana
sleep_semana <- sleep.no.na %>%
  group_by(Semana = floor_date(calendarDate, unit = "week")) %>%
  summarize(media_de_datos = round(mean(overallScore),2))

#Linea temporal del sueño por meses

sleep_mensual <- sleep.no.na %>%
  group_by(Mes = floor_date(calendarDate, unit = "month")) %>%
  summarize(media_de_datos = round(mean(overallScore),2))

#Dashboard con los 3 graficos dia,semana y mes

# Crear los tres gráficos separados
daily_plot <- ggplot(sleep_dia, aes(x = Dia, y = media_de_datos )) + 
  ggtitle ("Puntuación del sueño por días") +
  geom_line(aes(color = "Puntuación diaria"), linetype = "solid") + 
  geom_point(color="#3399FF", size=2.4) + 
  geom_text(data = sleep_dia, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("#3399FF"), labels = "Puntuación diaria") +
  scale_linetype_manual(values = c("solid"), labels = "Puntuación diaria") +
  ylab ("Puntuación del sueño")+
  xlab ("Días")+
  theme(legend.position = "none")  # ocultar la leyenda

weekly_plot <- ggplot(sleep_semana, aes(x = Semana, y = media_de_datos )) + 
  ggtitle ("Puntuación media del sueño por semanas") +
  geom_line(aes(color = "Puntuación semanal"), size=1, linetype = "dashed") +
  geom_point(color="#FF5733", size=2.4) +
  geom_text(data = sleep_semana, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("#FF5733"), labels = "Puntuación semanal") +
  scale_linetype_manual(values = c("dashed"), labels = "Puntuación semanal") +
  ylab ("Puntuación del sueño")+
  xlab ("Semanas")+
  theme(legend.position = "none")  # ocultar la leyenda

monthly_plot <- ggplot(sleep_mensual, aes(x = Mes, y = media_de_datos )) + 
  ggtitle ("Puntuación media del sueño por meses") +
  geom_line(aes(color = "Puntuación mensual"), size=1, linetype = "dotted") +
  geom_point(color="green", size=2.4) +
  geom_text(data = sleep_mensual, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("green"), labels = "Puntuación mensual") +
  scale_linetype_manual(values = c("dotted"), labels = "Puntuación mensual") +
  ylab ("Puntuación del sueño")+
  xlab ("Meses")+
  theme(legend.position = "none")  # ocultar la leyenda

# Unir los tres gráficos en un panel

library(gridExtra)

grid.arrange(daily_plot, weekly_plot, monthly_plot, ncol=1)

#Automatizacion graficos 

library(calendR)
library(dplyr)
library(lubridate)

generar_calendario <- function(año, mes, sleep.no.na) {
  datos_mes <- sleep.no.na %>%
    filter(year(calendarDate) == año, month(calendarDate) == mes) %>%
    complete(calendarDate = seq(as.Date(paste0(año, "-", mes, "-01")), as.Date(paste0(año, "-", mes, "-", days_in_month(as.Date(paste0(año, "-", mes, "-01"))))), by="day")) %>%
    mutate(overallScore = ifelse(is.na(overallScore), -1, overallScore)) %>%
    dplyr::select(calendarDate, overallScore) %>%
    mutate(overallScore = (overallScore/100)) %>%
    pull(overallScore)
  
  dias <- rep(min(datos_mes)-0.05, days_in_month(as.Date(paste0(año, "-", mes, "-01"))))
  dias[!is.na(datos_mes)] <- datos_mes[!is.na(datos_mes)]
  
  calendR(year = año,
          month = mes,
          special.days = dias,
          gradient = TRUE,
          low.col = "white",
          special.col = "#3399FF",
          legend.pos = "bottom",
          legend.title = "Puntuación del sueño",
          start = c("M")) 
}

#Extrae las fechas únicas de la columna de fecha
unique_dates <- unique(sleep.no.na$calendarDate)

# Convierte las fechas a formato POSIXlt para poder acceder a los componentes de año y mes
date_components <- as.POSIXlt(unique_dates)

# Define los rangos de años y meses para los que deseas generar gráficos
years <- unique(year(sleep.no.na$calendarDate))
months <- unique(month(sleep.no.na$calendarDate))

for (year in years) {
  months <- unique(month(sleep.no.na$calendarDate[year(sleep.no.na$calendarDate) == year]))
  for (month in months) {
    p <- generar_calendario(year, month, sleep.no.na)
    plot(p)
  }
}

#Pruebas para determinar la idoneidad de la regresión lineal

cor(sleep.no.na$totalsleepH, sleep.no.na$overallScore) 
   
modelo <- lm(overallScore ~ totalsleepH, data = sleep.no.na)
summary(modelo)

nuevos_valores <- data.frame(totalsleepH = c(6,7, 8, 9,10)) # nuevos valores de totalsleeph
predicciones <- predict(modelo, nuevos_valores) # hacer predicciones

predict(modelo, newdata = sleep.no.na) #predeccion para todo el conjunto de datos

#Grafico regresion lineal

ggplot(sleep.no.na, aes(x = totalsleepH, y = overallScore)) +
  geom_point(color="#3399FF", alpha=0.4, size=3, position = "jitter") + 
  ylab("Puntuación del sueño") + 
  xlab("Horas sueño") +
  ggtitle("Gráfico de regresión lineal simple") +
  scale_x_continuous(limits = c(3,12.5), breaks = seq(3,12.5,1)) +
  geom_smooth(method = "lm", se = TRUE, level = 0.99)

#Transformación conjunto de datos para hacer análisis PCA 

sleep.pca <- sleep.no.na

sleep.pca$calendarDate <- NULL
sleep.pca$totalsleepH <- NULL
sleep.pca$feedback <- NULL
sleep.pca$totalsleepMin <- NULL

#Transformación de las variables sleepMeasurementStartGMT y sleepMeasurementEndGMT para extraer solo la hora

fecha_hora_start <- as.character(sleep.pca$sleepMeasurementStartGMT)
fecha_hora_end <- as.character(sleep.pca$sleepMeasurementEndGMT)

fecha_end <- substr(sleep.pca$sleepMeasurementEndGMT, 1, 10)
hora_end <- substr(sleep.pca$sleepMeasurementEndGMT, 12, 19)

fecha_start <- substr(sleep.pca$sleepMeasurementStartGMT, 1, 10)
hora_start <- substr(sleep.pca$sleepMeasurementStartGMT, 12, 19)

sleep.pca$sleepMeasurementStartGMT <- NULL
sleep.pca$sleepMeasurementEndGMT <- NULL

#Unir las nuevas variables temporales y ordenar el conjunto de datos

sleep.pca <- cbind(sleep.pca, hora_start, hora_end)

sleep.pca<- dplyr::select(sleep.pca,hora_start,hora_end, everything())

#Redondear la hora a la mas proxima

sleep.pca$hora_start <- as.POSIXct(sleep.pca$hora_start, format = "%H:%M:%S", origin = "1970-01-01")
sleep.pca$hora_start <- round_date(sleep.pca$hora_start, unit = "hour")
sleep.pca$hora_start <- format(sleep.pca$hora_start, format = "%H:%M:%S")

sleep.pca$hora_end <- as.POSIXct(sleep.pca$hora_end, format = "%H:%M:%S", origin = "1970-01-01")
sleep.pca$hora_end <- round_date(sleep.pca$hora_end, unit = "hour")
sleep.pca$hora_end <- format(sleep.pca$hora_end, format = "%H:%M:%S")

#Transformacion de las horas a valores numericos

sleep.pca$hora_start <- substr(sleep.pca$hora_start, 1, 2)
sleep.pca$hora_end  <- substr(sleep.pca$hora_end, 1, 2)

sleep.pca$hora_start<-as.numeric(sleep.pca$hora_start)
sleep.pca$hora_end <-as.numeric(sleep.pca$hora_end)

#Transformar el formato 24h por debajo de las 00h hora negativa las 00 = a 0 y or encima del as 00h valor positivo se deja como esta

sleep.pca$hora_start <- ifelse(sleep.pca$hora_start <=23 & sleep.pca$hora_start>12, sleep.pca$hora_start-24,sleep.pca$hora_start)

  sleep.pca1 <- sleep.pca
 
# El sleep.pca original se hace sin modificar las variables, PCA1 sera solo con las variables de puntuacion y el pca2 sera sin las variables de puntuacion menos overallScore

  #PCA1 sin variables de tiempo solo puntuaciones y recuentos de frecuencias
  sleep.pca1[,3:6] <- NULL
  sleep.pca1$awakeningsCountScore <- NULL
  sleep.pca1$awakeTimeScore <- NULL
  sleep.pca1$lowestRespiration <- NULL
  sleep.pca1$highestRespiration <- NULL
  
#Análisis PCA 

library(FactoMineR)

pca<-PCA(X = sleep.pca1, scale.unit = TRUE, ncp= 19, graph = FALSE)
pca1<-prcomp(sleep.pca1, scale. = TRUE)

#Tabla eigen value y % acumulado de varianza explicada

eig.var<-head(pca$eig,10) # PC6 = 83,15 / 19 variables  el 6 PC es un eigenvalue 1> aporta menos que una variable normal pero asi explicamos el 83,15% de la varianza de los datos
colnames(eig.var) <- c("Eigenvalue", "Proportion of Variance", "% Acumulado")
eig.var <- head(pca$eig, 10)
rownames(eig.var) <- paste("comp", 1:nrow(eig.var))
colnames(eig.var) <- c("Eigenvalue", "Proportion of Variance", "% Acumulado")
eig.var <- subset(eig.var, select = c("Eigenvalue", "% Acumulado"))

eig.var <- as.data.frame(eig.var)

#Graficos PCA

library(factoextra)
library(cartography)
library(paletteer)
library(rgl)

p1<-fviz_eig(pca, addlabels = TRUE, choice = "eigenvalue", main = "Scree plot eigenvalue") 
p2<-fviz_eig(pca, addlabels = TRUE, choice = "variance", main = "Scree plot variance") 

# Crear el panel con los dos gráficos
grid.arrange(p1, p2, ncol = 2)

# componentes totales del grafico

n_comp.eig <- length(p1$data$eig)

n_comp.var <- length(p2$data$eig)

#PCA
fviz_pca_ind(pca,
             col.ind = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             title= "PCA mediciones") #grafico de individuos, Avoid text overlapping

fviz_pca_var(pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE,
             title= "PCA variables") # grafico de variables

#Graficos de contribucion de variables a PC

v1<-fviz_contrib(pca, axes = 1, choice = "var", title ="PC 1") 
v2<-fviz_contrib(pca, axes = 2, choice = "var", title ="PC 2") 
v3<-fviz_contrib(pca, axes = 3, choice = "var", title ="PC 3") 
v4<-fviz_contrib(pca, axes = 4, choice = "var", title ="PC 4") 
v5<-fviz_contrib(pca, axes = 5, choice = "var", title ="PC 5") 
v6<-fviz_contrib(pca, axes = 6, choice = "var", title ="PC 6") 

#Union de los graficos

grid.arrange(v1,v2,ncol = 1)
grid.arrange(v3,v4,ncol=1)
grid.arrange(v5,v6,ncol = 1)

### Crear cuadrantes
# Obtener las coordenadas de los individuos en los dos primeros componentes principales

x <- pca1$x[,1]
y <- pca1$x[,2]

# Inicializar un vector para almacenar los cuadrantes de cada individuo

cuadrantes <- rep(NA, length(x))

# Determinar el cuadrante de cada individuo

cuadrantes[x >= 0 & y >= 0] <- 1
cuadrantes[x < 0 & y >= 0] <- 2
cuadrantes[x < 0 & y < 0] <- 3
cuadrantes[x >= 0 & y < 0] <- 4

# Ver los resultados

cuadrantes

frecuencias <- table(cuadrantes)

### Gráfico de cuadrantes mas las variables del PCA

library(ggrepel)

# Crear un data frame con las coordenadas de los individuos y el cuadrante al que pertenecen

datos <- data.frame(x = pca1$x[,1], y = pca1$x[,2], cuadrante = cuadrantes)

# Calcular el factor de escala

escala <- max(abs(datos$x), abs(datos$y))

# Obtener las coordenadas de las flechas que representan a las variables

flechas <- data.frame(
  x0 = 0,
  y0 = 0,
  x1 = pca1$rotation[,1] * escala,
  y1 = pca1$rotation[,2] * escala,
  variable = rownames(pca1$rotation)
)

# Calcular frecuencias de cuadrantes

frecuencias <- table(cuadrantes)
total_casos <- sum(frecuencias)

# Crear una etiqueta para cada cuadrante que incluya el número de individuos

datos$Cuadrantes <- paste("Cuadrante", datos$cuadrante, "\nn = ", frecuencias[as.character(datos$cuadrante)], "(",
                    round(frecuencias[as.character(datos$cuadrante)]/sum(frecuencias)*100, 1),"%)")

# Crear el gráfico de dispersión con las flechas que representan a las variables
pca_l <-  ggplot(datos, aes(x = x, y = y)) +
  geom_point(aes(color = Cuadrantes)) +
  geom_segment(data = flechas, aes(x = x0, y = y0, xend = x1, yend = y1), arrow = arrow(length = unit(0.5, "cm"))) +
  ggrepel::geom_text_repel(data = flechas, aes(x = x1, y = y1, label = variable)) +
  ggtitle("Gráfico de dispersión de individuos y variables por cuadrantes")+
  theme(panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black")) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_ellipse(aes(fill = Cuadrantes), geom = "polygon", alpha = 0.2)+
    scale_color_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#9C27B0")) +
    scale_fill_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#260F99"))+
    labs(color = paste("Cuadrantes\n(n =", total_casos, ")"))+
    guides(fill = guide_legend(title = paste("Cuadrantes\n(n =", total_casos, ")")))

#llamar grafico

pca_l

# Regresion lineal simple con los 6 PC

pca_X <- pca$ind$coord[, 1:6]
modelo_pca <- lm(sleep.pca$overallScore ~ pca_X)

pca_X <- data.frame(pca_X)

# Obtenemos un resumen del modelo

resumen_modelopca <- summary(modelo_pca)

for (col in colnames(pca_X)) {
  cor_value <- cor(pca_X[[col]], sleep.pca$overallScore)
  cat(col, ":", cor_value, "\n")
}

library("GGally")

# Crear un data frame con todas las variables
data_all <- data.frame(sleep.pca$overallScore, pca_X)

data_all$sleep.pca.overallScore

names(data_all) <- c("overallScore", paste0("PC", 1:6))

#Matriz de correlacion multiple y regresion lineal multiple

p_scatter <- ggpairs(data_all, columns = 1:7, lower = list(continuous = function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping) +
    geom_point(alpha = 0.4, color = "#3399FF", position = "jitter") +
    geom_smooth(method = "lm", se = TRUE, level = 0.99) +
    theme_bw()
}))

p_scatter <- p_scatter +
  theme(panel.background = element_rect(fill = "white", colour = "gray"))

p_scatter



```

### __1. Introducción__

Como bien indica el título de este proyecto __¿Como conseguir un mejor descanso?__, este trabajo pretende realizar un análisis estadístico sobre métricas del sueño. Pero antes es oportuno realizar una aproximación a que es el sueño, que función tiene y algunos apuntes básicos para que nos permitiran tener un buen descanso.

El sueño es un estado fisiológico durante el cual nuestro cuerpo se relaja, se calma nuestro sistema nervioso, nuestra respiración se vuelve más lenta y profunda, nuestra actividad cerebral cambia, permitiendo de esta forma que nuestro cerebro y nuestro cuerpo rejuvenezcan.

El sueño cumple con varias funciones importantes en nuestro cuerpo: consolidación de la memoria, regulación de la temperatura corporal, reparación y regeneración de tejidos, regulación del metabolismo y el sistema inmunológico. También juega un papel crucial en el mantenimiento de nuestro bienestar emocional y mental.

Para tener un buen descanso con el sueño, se recomienda seguir estas prácticas:

1. Establecer un horario de sueño regular y tratar de mantenerlo incluso los fines de semana.
2. Crear un ambiente tranquilo y oscuro para dormir.
3. Evitar la cafeína, el alcohol y el tabaco antes de dormir.
4. Realizar actividades relajantes antes de acostarse, como leer o tomar un baño caliente.
5. Mantener una temperatura cómoda en la habitación para dormir.
6. Evitar las siestas largas durante el día.
7. Mantener una rutina de ejercicio regular, pero evitar el ejercicio intenso antes de dormir.
8. Limitar el uso de dispositivos electrónicos antes de dormir, ya que la luz azul emitida por estas pantallas dificulta la conciliación del sueño.

Siguiendo estas recomendaciones, podemos mejorar la calidad del sueño y asegurar que cuerpo y mente se recuperan adecuadamente durante el descanso nocturno.

El sujeto nos ha proporcionado información extra, externa a los datos recogidos que nos permiten interpretar algunas de las tendencias de los datos que disponemos:

- En el mes de junio el sujeto trabajaba en turnos nocturnos, hecho que le provocaba dormir pocas horas y de mala calidad. Hecho que creemos que afectará a la calidad del sueño.
- En el mes de septiembre el sujeto realizó una sustitución en horario nocturno durante la tercera semana del mes. 
- En el mes de enero el sujeto estaba en una situación de estrés debido a su nuevo trabajo, en el cual hacía jornadas largas de más 8h muchos días. Además de los nervios de ser el primer mes que trabajaba 100% a comisión sin sueldo fijo, y con mucha presión por parte de la empresa. Debido a toda esta situación estaba valorando la opción de dejar el trabajo, y finalmente el 31 de enero fue su último día de trabajo. 

### __2. Obtención de los datos__

Los datos biométricos extraídos para analizar la calidad del sueño, provienen de un smartwatch modelo __Garmin Fenix 6X Pro__. El smartwatch recoge una gran cantidad de métricas para medir el sueño y determinar si se ha tenido un buen descanso. Para obtener los datos hay que realizar una solicitud a Garmin desde su página: https://www.garmin.com/es-ES/account/datamanagement/exportdata/. Ellos los compilan y posteriormente te los mandan en formato JSON. 

Los datos proporcionados están divididos en tres archivos distintos, el primer archivo tiene __`r ncol(sleep1t)` variables__ y los otros dos archivos tienen __`r ncol(sleep2t)` variables__, a excepción de las dos variables de más que tiene el primer archivo, comparten la misma estructura y formato. El lapso temporal de los datos que se dispone para el estudio van desde el _`r sleep123t$calendarDate[1]`_ hasta el _`r sleep123$calendarDate[length(sleep123t$calendarDate)]`_, un total de __`r nrow(sleep123t)` días__. 

Las variables que recoge el dispositivo pertinentes para determinar la calidad del sueño se agrupan en 5 tipos:

1. Métricas relacionadas con el sueño (en segundos): 

- deepSleepSeconds
- lightSleepSeconds
- remSleepSeconds
- awakeSleepSeconds

2. Métricas de biodatos (se recogen en una lista spo2SleepSummary): 

- averageSPO2
- averageHR
- lowestSPO2
- averageRespiration
- lowestRespiration
- highestRespiration
- awakeCount 
- avgSleepStress

3. Métricas de puntuación sobre la calidad del sueño de 0 a 100 (se recogen en una lista de variables sleepScores). Garmin valora la puntuación de estas variables de la siguiente forma:

```{r grupos sueño, include=TRUE, echo=FALSE}
# Crear un data.frame con los nombres y valores de los grupos
library(knitr)
grupos.df <- data.frame(
  Grupos = c("Pobre", "Justo", "Bueno", "Excelente"),
  Valores = c("0-60", "60-79", "79-89", "89-100")
)
kable(grupos.df, row.names = FALSE, comment = FALSE, align = c("l", "r"))
```

- overallScore
- qualityScore
- durationScore
- recoveryScore
- deepScore
- remScore
- lightScore
- awakeiningsScore
- awakeTimeScore
- combinatedAwakeScore
- resfultnedsScore
- interruptionsScore
- restlessMomentCount

4. Variables temporales que marcan la fecha de inicio y fin del sueño.

5. Variables factoriales en formato texto que evalúan el sueño de forma positiva o negativa.

Este es la estructura de los datos que proporciona Garmin, pero para poder trabajar con estos datos hemos tenido que unificar los datos en un solo conjunto. El proceso de unificación de los datos ha constado de dos fases:

1. Eliminación de las dos variables que solo poseía el primer conjunto de datos _sleep1_.

2. Extracción de las variables que estaban agrupadas en listas para poder usar la función _cbind()_. Tras realizar todo este proceso pasamos de tener `r ncol(sleep2t)` variables iniciales a `r ncol(sleep.no.na)` variables.

Con los datos ya agrupados en _sleep123_ se ha llevado a cabo el siguiente proceso de transformación del conjunto de datos: 

- Eliminación de variables que no aportan información útil para el análisis.
- Transformación de las variables que miden el tiempo de sueño en segundos a minutos.
- Creación de dos variables nuevas, resultado de la suma de las variables que miden los distintos tipos de sueño, expresadas en minutos y horas (para facilitar la comprensión de los datos). 
- Recodificación de las variables al formato adecuado: las temporales como date, las factoriales como factor y por último las integer se han transformado con un bucle a numeric para evitar problemas durante el proceso de análisis estadístico.
- Eliminación de casos no validos y valores NA para evitar sesgos en el estudio.

Éste proceso de transformación y depuración de los datos como resultado ha dejado el conjunto de datos de la siguiente forma:  __`r nrow(sleep.no.na)` días__ de datos recogidos y __`r ncol(sleep.no.na)` variables__.

### __3. Análisis exploratorio__

Comenzaremos realizando un análisis de dispersión de las mediciones agrupándolas según la clasificación de Garmin:

```{r Gráfico grupos calidad sueño, include=TRUE, echo=FALSE}
#creacion grupos de sueño

grupos <- cut(sleep.no.na$overallScore, 
              breaks = c(0, 60, 79, 89, 100),
              labels = c("Pobre", "Justo", "Bueno", "Excelente"))

# Cálculo de frecuencia y porcentaje de cada grupo
grupos_count <- table(grupos)
total_casos <- sum(grupos_count)

# Modificación de la variable grupo_label para incluir el rango de cada etiqueta
grupo_range <- c("0-60", "60-79", "79-89", "89-100")
grupo_label <- paste0(names(grupos_count), " (", grupo_range, "): n = ", grupos_count, " (", 
                      round(100*grupos_count/total_casos,2), "%)")

# Creación del gráfico
ggplot(sleep.no.na, aes(x = totalsleepH, y = overallScore)) +
  geom_point(aes(color = grupos), alpha = 0.7, size = 3, position = "jitter") + 
  ylab("Puntuación del sueño") + 
  xlab("Horas sueño") +
  ggtitle("Gráfico calidad del sueño por grupos") +
  scale_x_continuous(limits = c(3,12.5), breaks = seq(3,12.5,1)) +
  scale_color_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#9C27B0"),
                     labels = grupo_label) +
  labs(color = "Calidad del sueño") +
  guides(color = guide_legend(title = paste0("Grupos (n = ", total_casos, ")"), 
                              ncol = 1, 
                              override.aes = list(size = 3, alpha = 0.4)))

```

```{r automatización del texto calidad sueño, include=TRUE, echo=FALSE}
pj<-sum(grupos_count[1:2])
be<-sum(grupos_count[3:4])

pj1<- (pj/nrow(sleep.no.na))*100
be1<- (be/nrow(sleep.no.na))*100
```

Podemos observar cierta correlación en la distribución de los datos, no se observa agrupaciones en los datos la suma de los dos primeros grupos son __`r pj`__ mediciones que suponen el __`r pj1`%__ de los casos. Los dos grupos superiores suman __`r be`__ mediciones que suponen el __`r be1`%__ de los casos.

Para poder observar el comportamiento de los datos a escala temporal, se ha generado un _dashboard_ que nos permitirá ver con mayor detalle la dispersión de la calidad del sueño en el tiempo de las mediciones tomadas, estos tres gráfico nos permiten observar el comportamiento de los datos en distintas escalas temporales en la puntuación de __overallScore__: 

1. El primer gráfico muestra la puntuación de forma diaria.
2. El segundo gráfico muestra la media de la puntuación del sueño por semanas.
3. El tercer gráfico muestra la media de la puntuación del sueño por meses.

```{r Gráficos lineales, include=TRUE, echo= FALSE}
#Linea temporal del sueño por dia

sleep_dia <- sleep.no.na %>%
  group_by(Dia = floor_date(calendarDate, unit = "day")) %>%
  summarize(media_de_datos = overallScore)

#Linea temporal del sueño por semana
sleep_semana <- sleep.no.na %>%
  group_by(Semana = floor_date(calendarDate, unit = "week")) %>%
  summarize(media_de_datos = round(mean(overallScore),2))

#Linea temporal del sueño por meses

sleep_mensual <- sleep.no.na %>%
  group_by(Mes = floor_date(calendarDate, unit = "month")) %>%
  summarize(media_de_datos = round(mean(overallScore),2))

# Crear los tres gráficos separados

daily_plot <- ggplot(sleep_dia, aes(x = Dia, y = media_de_datos )) + 
  ggtitle ("Puntuación del sueño por días") +
  geom_line(aes(color = "Puntuación diaria"), linetype = "solid") + 
  geom_point(color="#3399FF", size=2.4) + 
  geom_text(data = sleep_dia, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("#3399FF"), labels = "Puntuación diaria") +
  scale_linetype_manual(values = c("solid"), labels = "Puntuación diaria") +
  ylab ("Puntuación del sueño")+
  xlab ("Días")+
  theme(legend.position = "none")  # ocultar la leyenda

weekly_plot <- ggplot(sleep_semana, aes(x = Semana, y = media_de_datos )) + 
  ggtitle ("Puntuación media del sueño por semanas") +
  geom_line(aes(color = "Puntuación semanal"), size=1, linetype = "dashed") +
  geom_point(color="#FF5733", size=2.4) +
  geom_text(data = sleep_semana, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("#FF5733"), labels = "Puntuación semanal") +
  scale_linetype_manual(values = c("dashed"), labels = "Puntuación semanal") +
  ylab ("Puntuación del sueño")+
  xlab ("Semanas")+
  theme(legend.position = "none")  # ocultar la leyenda

monthly_plot <- ggplot(sleep_mensual, aes(x = Mes, y = media_de_datos )) + 
  ggtitle ("Puntuación media del sueño por meses") +
  geom_line(aes(color = "Puntuación mensual"), size=1, linetype = "dotted") +
  geom_point(color="green", size=2.4) +
  geom_text(data = sleep_mensual, aes(label = media_de_datos), hjust = -0.1, size = 3.3, nudge_y = 0.6, fontface="bold") +
  scale_x_date(date_breaks ="1 month", date_labels = "%b %y") +
  scale_color_manual(values = c("green"), labels = "Puntuación mensual") +
  scale_linetype_manual(values = c("dotted"), labels = "Puntuación mensual") +
  ylab ("Puntuación del sueño")+
  xlab ("Meses")+
  theme(legend.position = "none")  # ocultar la leyenda

# Unir los tres gráficos en un panel

grid.arrange(daily_plot, weekly_plot, monthly_plot, ncol=1)
```

A través de esta visualización podemos ver el comportamiento de _overallScore_ desde _`r sleep.no.na$calendarDate[1]`_ hasta _`r sleep.no.na$calendarDate[length(sleep.no.na$calendarDate)]`_ en tres diferentes escalas temporales, diaria, media semanal y media mensual. Si miramos el gráfico mensual vemos que desde el inicio de las mediciones hasta el final de las mismas ha habido un incremento en la calidad del sueño. Y si observamos los semanales y diarios nos ayudan a ver los altibajos en la puntuación del sueño con más detalle para entender los datos mensuales.

Si observamos la media de junio del 2022 el mes con menor puntuación, en los gráficos de las mediciones semanales podemos observar que también tiene medias bajas y si observamos los datos diarios podemos ver que oscilan mucho las puntuaciones pero con pocas puntuaciones altas. Si hacemos las mismas observaciones con los restos de meses a excepción de septiembre del 2022 y enero del 2023 que se parecen más al primer mes comentado, el resto tienen puntuaciones más altas como tendencia, hecho que hace subir las observaciones tanto en las medias semanales como mensuales.

Las puntuaciones más bajas en el gráfico diario son los días que menos horas se ha dormido por norma general, por lo que creemos que la cantidad total de tiempo dormido es una variable que influye en la puntuación de _overallScore_. Para poder ver con mayor detalle los días de los que se dispone información sobre el sueño, hemos generado una serie temporal de gráficos de calor con la puntuación de _overallScore_ escalada de 0 a 1.

```{r Gráficos de calor mensuales, echo= FALSE}

generar_calendario <- function(año, mes, sleep.no.na) {
  datos_mes <- sleep.no.na %>%
    filter(year(calendarDate) == año, month(calendarDate) == mes) %>%
    complete(calendarDate = seq(as.Date(paste0(año, "-", mes, "-01")), as.Date(paste0(año, "-", mes, "-", days_in_month(as.Date(paste0(año, "-", mes, "-01"))))), by="day")) %>%
    mutate(overallScore = ifelse(is.na(overallScore), -1, overallScore)) %>%
    dplyr::select(calendarDate, overallScore) %>%
    mutate(overallScore = (overallScore/100)) %>%
    pull(overallScore)
  
  dias <- rep(min(datos_mes)-0.05, days_in_month(as.Date(paste0(año, "-", mes, "-01"))))
  dias[!is.na(datos_mes)] <- datos_mes[!is.na(datos_mes)]
  
  calendR(year = año,
          month = mes,
          special.days = dias,
          gradient = TRUE,
          low.col = "white",
          special.col = "#3399FF",
          legend.pos = "bottom",
          legend.title = "Puntuación del sueño",
          start = c("M")) 
  
}

#Extrae las fechas únicas de la columna de fecha
unique_dates <- unique(sleep.no.na$calendarDate)

# Convierte las fechas a formato POSIXlt para poder acceder a los componentes de año y mes
date_components <- as.POSIXlt(unique_dates)

# Define los rangos de años y meses para los que deseas generar gráficos
years <- unique(year(sleep.no.na$calendarDate))
months <- unique(month(sleep.no.na$calendarDate))

for (year in years) {
  months <- unique(month(sleep.no.na$calendarDate[year(sleep.no.na$calendarDate) == year]))
  for (month in months) {
    p <- generar_calendario(year, month, sleep.no.na)
    plot(p)
  }
}
```

Queremos observar si el tiempo total de sueño _totalsleepH_ influye en la puntuación obtenida en _overallScore_. Para valorar si existe relación entre estas dos variables vamos realizar una prueba de correlación entre ellas:

### __4. Análisis estadístico__
##### __4.1 Regresión lineal simple__

- Prueba de correlación:
```{r Correlación, include= TRUE, results='hold', echo= FALSE}
cor(sleep.no.na$totalsleepH, sleep.no.na$overallScore) 
```
Los resultados de la prueba de correlación son positivos, muestran que existe una relación positiva y moderada, confirmando de esta forma que es correcto realizar un modelo de análisis de regresión lineal. 

- Modelo estadístico de regresión lineal:
```{r Modelo estadístico, include=TRUE, results='hold', echo= FALSE}
modelo <- lm(overallScore ~ totalsleepH, data = sleep.no.na)

resultados1 <- summary(modelo)$coefficients

# Ajustar el número de decimales para Estimate, Std. Error y t value

resultados1[, 1:3] <- round(resultados1[, 1:3],3)

# Convertir los valores de Pr(>|t|) en formato cientifico

resultados1[, 4] <- format.pval(resultados1[, 4], scientific = TRUE)

knitr::kable(resultados1, caption = "Coeficientes del modelo de regresión lineal simple", table.envir= "table") %>%
  kableExtra::column_spec(1, width = "2.5cm") %>%
  kableExtra::column_spec(2, width = "2.5cm") %>%
  kableExtra::column_spec(3, width = "2.5cm") %>%
  kableExtra::column_spec(4, width = "2.5cm") %>%
  kableExtra::column_spec(5, width = "2.5cm")

#R cuadrado y R cuadrado ajustado

resultados2 <- rbind(c("R-squared", round(summary(modelo)$r.squared, 3)))
resultados2 <- rbind(resultados2,c("Adjusted R-squared", round(summary(modelo)$adj.r.squared, 3)))

# Imprime la tabla de resultados

knitr::kable(resultados2, caption = "$R^2$ y $R^2$ ajustado", table.envir= "table") %>%
  kableExtra::column_spec(1, width = "2.5cm") %>%
  kableExtra::column_spec(2, width = "2.5cm") 
 
```
 
La ecuación de la recta de la regresión es: $overallScore = `r resultados1[1,1]` + `r resultados1[2,1]`(totalsleepH)$. De aquí podemos extraemos que si una persona no duerme nada su puntuación de  __overallScore__ será $Intercept = `r resultados1[1,1]`$. El coeficiente de __totalsleepH__ es $\beta = `r resultados1[2,1]`$, muestra la existencia de una pendiente positiva y por cada hora adicional de sueño del sujeto, se espera un aumento de $\Delta y = `r resultados1[2,1]`$ en la puntuación de __overallScore__.

Este modelo de análisis es significativo debido a que el $p-valor = `r resultados1[2,4]`$ es inferior a $p-valor < 0.05$, demostrando que es muy poco probable que esta relación causal sea fruto del azar.

```{r automatización texto, include=TRUE, echo= FALSE}
modelo1t <- lm(overallScore ~ totalsleepH, data = sleep.no.na)

resultados1t <- summary(modelo1t)$coefficients

# Ajustar el número de decimales para Estimate, Std. Error y t value

resultados1t[, 1:3] <- round(resultados1t[, 1:3],3)

# Convertir los valores de Pr(>|t|) en formato cientifico

resultados1t[, 4] <- format.pval(resultados1t[, 4], scientific = TRUE)

#R cuadrado y R cuadrado ajustado

resultados2t <- rbind(round(summary(modelo1t)$r.squared, 3))
resultados2t <- rbind(resultados2t,c(round(summary(modelo1t)$adj.r.squared, 3)))
```

El valor de $R^2_{ajustado} = `r resultados2t[2,]`$ nos indica que este modelo de regresión lineal simple explica el __`r resultados2t[2,]*100`%__ de la variabilidad en __overallScore__.

El valor del error estándar residual indica la cantidad de variabilidad no explicada en el modelo, y se puede utilizar para evaluar la precisión de las predicciones del modelo. En este caso, el valor del error estándar residual es $t-value = `r resultados1t[1,3]`$, lo que significa que las predicciones del modelo pueden tener un error aproximado de `r resultados1t[1,3]` puntos.

```{r Gráfico de regresión lineal simple, include=TRUE, results='hold', echo= FALSE}
ggplot(sleep.no.na, aes(x = totalsleepH, y = overallScore)) +
  geom_point(color="#3399FF", alpha=0.4, size=3, position = "jitter") + 
  ylab("Puntuación del sueño") + 
  xlab("Horas sueño") +
  ggtitle("Gráfico de regresión lineal simple") +
  scale_x_continuous(limits = c(3,12.5), breaks = seq(3,12.5,1)) +
  geom_smooth(method = "lm", se = TRUE, level = 0.99)
```

El gráfico de regresión lineal muestra la relación entre la variable __independiente x=totalsleepH__ y la variable __dependiente y=overallScore__. Como hemos observado antes con la ecuación de la recta entre las 5 y 10 horas de sueño se concentran la mayor parte de las mediciones en la calidad del sueño del sujeto, cumpliendo que a mayor cantidad de horas dormidas __x=totalsleepH__ mayor puntuación en __y=overallScore__ lo que indica que a más horas de sueño, mayor puntuación en la calidad del sueño. 

Hemos podido observar que este modelo solo es capaz de explicar el __`r resultados2t[2,]*100`%__ de la variabilidad en __overallScore__. En el gráfico de regresión lineal podemos observar que hay casos que no cumplen con la ecuación de la recta a más horas de sueño mayor puntuación de __overallScore__. Por ello y para poder mejorar éste análisis inicial usaremos todos los datos y variables de las que disponemos para realizar un análisis de PCA (Principal Component Analisys).


##### __4.2 Análisis PCA__

Para poder realizar un análisis de PCA se ha tenido que transformar el conjunto de datos nuevamente para poder cumplir con los requisitos estádisticos que requiere hacer el análisis:

1. Eliminación de variables no numéricas. 
2. Transformación de las variables temporales a través de varios procesos: 

   2.1 Selección solo de la hora de inició y fin de la medición del sueño, eliminando la fecha. 
   
   2.2 Transformación del formato de hora de hh:mm a hh(las horas que no tenían una medición a en punto, se las ha redondeando al valor hh más cercano). 
   
   2.3 Recodificación de esta nueva variable a valor numérico. 
   
   2.4 Transformación de los valores de inicio de medición temporal redondeados: aquellos que están por debajo de las 23h se les ha restado -24 para diferenciarlos de las horas después de las 00h. 
   
3. Eliminación de las variables de medición del tiempo de sueño en minutos.
4. Eliminación de cuatro variables de puntuación sobre las mediciones de __Garmin Fenix 6x Pro__.

Después de esta nueva fase de depuración, el conjunto de datos tiene __`r ncol(sleep.pca1)` variables__ y __`r nrow(sleep.pca1)` mediciones__.

##### __4.2.1 Análisis exploratorio PCA__

Podemos graficar el objeto creado a través del PCA con el nombre _pca_ para entender mejor nuestros datos. Ambos gráficos tienen un degradado basado en el $Cos^2$ para medir la calidad de la representación de las observaciones en el plano de los componentes principales, tanto para individuos (primer gráfico) como para variables (segundo gráfico):

```{r Gráfico mediciones cos2, include=TRUE, echo= FALSE}
fviz_pca_ind(pca,
             col.ind = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             title= "PCA mediciones") 
```

El gráfico de mediciones nos permite observar la existencia de agrupaciones en nuestro conjunto de datos. En caso de existir una clara agrupación de los datos nos permitiría realizar un análisis de clustering. Pero como podemos observar en nuestros datos no se aprecia ninguna agrupación en los datos.

```{r Gráfico variables cos2, include=TRUE, echo= FALSE}
fviz_pca_var(pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE,
             title= "PCA variables") 
```

Ambos gráficos se interpretan de la misma manera: cuanto más bajo sea el valor del $Cos^2$, menor será la capacidad de representación de esas mediciones o variables en el conjunto del PCA. Por el contrario, cuanto mayor sea el valor del $Cos^2$, mayor será la capacidad de representación de esas mediciones o variables.

Si combinamos ambos gráficos en uno solo y eliminamos el degradado basado en el $Cos^2$, podemos obtener información adicional interesante:

```{r Gráfico de dispersión de individuos y variables por cuadrantes, include=TRUE, echo= FALSE}
# Crear el gráfico de dispersión con las flechas que representan a las variables
  ggplot(datos, aes(x = x, y = y)) +
  geom_point(aes(color = Cuadrantes)) +
  geom_segment(data = flechas, aes(x = x0, y = y0, xend = x1, yend = y1), arrow = arrow(length = unit(0.5, "cm"))) +
  ggrepel::geom_text_repel(data = flechas, aes(x = x1, y = y1, label = variable)) +
  ggtitle("Gráfico de dispersión de individuos y variables por cuadrantes")+
  theme(panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black")) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_ellipse(aes(fill = Cuadrantes), geom = "polygon", alpha = 0.2)+
    scale_color_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#9C27B0")) +
    scale_fill_manual(values = c("#FF5722", "#8BC34A", "#0288D1", "#260F99"))+
    labs(color = paste("Cuadrantes\n(n =", total_casos, ")"))+
    guides(fill = guide_legend(title = paste("Cuadrantes\n(n =", total_casos, ")")))
  
```

En este gráfico, debemos observar la distribución de los datos por cuadrantes en relación al eje (0,0). Hay cuatro cuadrantes, cada uno de ellos coloreado y resaltado con una elipse que agrupa los datos en su interior. Las mediciones agrupadas en el primer cuadrante están influenciadas por las variables que se encuentran dentro de ese mismo cuadrante. La longitud del vector que representa a cada variable nos muestra su importancia en relación a las mediciones existentes en el mismo cuadrante.

##### __4.2.2 Selección de PC__

Una de las principales ventajas del análisis PCA es su capacidad para reducir la dimensionalidad de un conjunto de datos al reducir el número de variables a través de la identificación de Componentes Principales (PC). Existen varios métodos para seleccionar los PC más importantes, pero en este trabajo solo consideraremos dos de ellos. El primer método consiste en seleccionar aquellos PC cuyo valor propio (eigenvalue) sea mayor que 1. Un valor propio inferior a 1 indica que la variable original aporta más información que el PC correspondiente. El segundo método consiste en seleccionar aquellos PC que expliquen un porcentaje acumulado de la varianza igual o superior al 80%.

```{r Eigenvalue y varianza explicada, include=TRUE, echo= FALSE}
p1<-fviz_eig(pca, addlabels = TRUE, choice = "eigenvalue", main = "Eigenvalue") 
p2<-fviz_eig(pca, addlabels = TRUE, choice = "variance", main = "% de varianza explicada acumulada") 

# Crear el panel con los dos gráficos
grid.arrange(p1, p2, ncol = 2)
```

```{r Texto automatizado, include=TRUE, echo= FALSE}
# Contar el número de filas donde el valor de "Eigenvalue" es mayor que 1
num_components <- sum(eig.var$Eigenvalue > 1)

num_componentst <- sum(eig.var$Eigenvalue)

# Mostrar el resultado
num_components

# componentes totales del grafico

n_comp.eig <- length(p1$data$eig)

n_comp.var <- length(p2$data$eig)

# Encontrar el índice del primer componente mayor al 80% de la varianza acumulada
index <- which(eig.var$`% Acumulado` >=80)[1]

# Mostrar el resultado
eig.var[index,]

# Acceder al valor de "% Acumulado" del componente correspondiente
acumulado <- eig.var[index, "% Acumulado"]

# Mostrar el resultado
acumulado<-round(acumulado,2)
```

En este _dashboard_ de Scree plots, podemos observar los primeros __`r n_comp.eig` PC__ en términos del porcentaje de varianza acumulada y del valor propio (eigenvalue).Estos gráficos nos ayudan a determinar cuántos PC debemos seleccionar. Utilizando el método de selección basado en el criterio de $eigenvalue> 1$, deberíamos seleccionar los primeros __`r num_components` PC__. Utilizando el segundo método, basado en el porcentaje de varianza acumulada explicada, deberíamos seleccionar los primeros __`r index` PC__, que suman un total de __`r acumulado`% varianza acumulada explicada__. Para nuestro estudio, utilizaremos el segundo método y seleccionaremos __`r index` PC__.

A continuación y una vez ya seleccionados los __`r index` PC__, vamos a ver que variables del conjunto de datos para entender que variables agrupa cada PC:

```{r Gráfico contribución PC, include=TRUE, echo= FALSE}
#Graficos de contribucion de variables a PC
v1<-fviz_contrib(pca, axes = 1, choice = "var", title ="PC 1") 
v2<-fviz_contrib(pca, axes = 2, choice = "var", title ="PC 2") 
v3<-fviz_contrib(pca, axes = 3, choice = "var", title ="PC 3") 
v4<-fviz_contrib(pca, axes = 4, choice = "var", title ="PC 4") 
v5<-fviz_contrib(pca, axes = 5, choice = "var", title ="PC 5") 
v6<-fviz_contrib(pca, axes = 6, choice = "var", title ="PC 6") 

#Union de los graficos
grid.arrange(v1,v2,ncol = 1)
grid.arrange(v3,v4,ncol=1)
grid.arrange(v5,v6,ncol = 1)
```

Están ordenados de mayor varianza explicada a menor varianza explicada como podemos observar en los Scree plot anteriores.

Para finalizar el apartado de análisis hemos creado una matriz de correlaciones y regresión lineal simple para todos los PC seleccionados.
```{r Matríz gráficos de correlación y correlaciones de los PC, include=TRUE, echo= FALSE}
#Matriz de correlacion multiple y regresion lineal multiple

p_scatter <- ggpairs(data_all, columns = 1:7, lower = list(continuous = function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping) +
    geom_point(alpha = 0.4, color = "#3399FF", position = "jitter") +
    geom_smooth(method = "lm", se = TRUE, level = 0.99) +
    theme_bw()
}))

p_scatter <- p_scatter +
  theme(panel.background = element_rect(fill = "white", colour = "gray"))

p_scatter
```

```{r automatización del texto, include=TRUE, echo= FALSE}
# Crear el objeto "modelo" con los coeficientes del modelo
modelo56 <- resumen_modelopca$coefficients

# Redondear los coeficientes
modelo56[, 1:3] <- round(modelo56[, 1:3], 3)

# Convertir los valores de Pr(>|t|) en formato científico
modelo56[, 4] <- format.pval(modelo56[, 4], scientific = TRUE)

# Imprimir la tabla de coeficientes
knitr::kable(modelo56, caption = "Coeficientes del modelo de regresión lineal simple", table.envir= "table") %>%
  kableExtra::column_spec(1, width = "2.5cm") %>%
  kableExtra::column_spec(2, width = "2.5cm") %>%
  kableExtra::column_spec(3, width = "2.5cm") %>%
  kableExtra::column_spec(4, width = "2.5cm") %>%
  kableExtra::column_spec(5, width = "2.5cm")

# Seleccionar los valores de R cuadrado y R cuadrado ajustado y redondear
rcuadrado <- round(resumen_modelopca$r.squared, 3)
rcuadrado_ajustado <- round(resumen_modelopca$adj.r.squared, 3)

# Crear la tabla de resultados de R cuadrado y R cuadrado ajustado
resultados <- rbind(c("R-squared", rcuadrado))
resultados <- rbind(resultados, c("Adjusted R-squared", rcuadrado_ajustado))

# Imprimir la tabla de resultados
knitr::kable(resultados, caption = "$R^2$ y $R^2$ ajustado", table.envir= "table") %>%
  kableExtra::column_spec(1, width = "2.5cm") %>%
  kableExtra::column_spec(2, width = "2.5cm")

```

El valor de $R^2_{ajustado} = `r rcuadrado_ajustado`$ nos indica que este modelo es capaz de explicar __`r rcuadrado_ajustado*100`%__ de la variabilidad en __overallScore__. En el gráfico matriz podemos observar todas las correlaciones de __overallScore__ en la primera fila con todos los PC y en la primera columna podemos ver todos los gráficos de dispersión.

### __5. Conclusiones__

Como hemos podido observar en el modelo de regresión lineal simple inicial la relación solo es capaz de explicar el __`r resultados2t[2,]*100`%__ de la varioanza explicada. Con el análisis PCA exploratorio en caso de haber observado la existencia de grupos en los datos se podría haber realizado un análisis de clusterings. Además nuestro PCA ha demostrado tener una baja redundancia, indicando que hay poca correlación entre las variables originales y que cada variable proporciona información única. 

Hemos continuado el PCA para reducir la dimensionalidad del conjunto de datos, seleccionado el número de PC con el método de __varianza acumulada explicada__, eligiendo de esta forma __`r index` PC__. Y de nuevo hemos vuelto a calcular un modelo de regresión lineal simple con todos los PC consiguiendo explicar __`r rcuadrado_ajustado*100`%__ de la variabilidad en __overallScore__

Debido a la falta de un marco teórico sólido sobre el sueño y sus implicaciones para poder modelar e interpretar adecuadamente los datos. Por esta razón, se ha llevado a cabo una aproximación inductiva con el objetivo de identificar las variables que tienen mayor influencia en la variable dependiente __overallScore__. Se creyó que la cantidad de tiempo dormido sería uno de los factores más determinantes y pese a que el primer modelo era capaz de explicar __`r resultados2t[2,]*100`%__ de los datos, este resultado nos mostraba que hay otras variables que afectan a la calidad del sueño.

Con el PCA se buscaba repetir el mismo proceso pero reduciendo la dimensionalidad para conseguir un mayor nivel de explicación __`r rcuadrado_ajustado*100`%__.

### __6. (In)Conclusiones__

Debido a su trabajo, el sujeto no ha podido seguir las recomendaciones para lograr un buen descanso mencionadas en la introducción. Para mejorar los resultados del estudio, sería interesante que el sujeto siguiera estas recomendaciones durante 1 o 2 meses. Luego, podríamos analizar los nuevos datos y compararlos con los resultados anteriores. De esta manera, podríamos realizar un _training-test_ con datos que cumplen con las premisas necesarias para tener un buen descanso y otros que no necesariamente las cumplen. Así, podríamos analizar con mayor detalle los efectos de las distintas variables en la calidad del sueño.
